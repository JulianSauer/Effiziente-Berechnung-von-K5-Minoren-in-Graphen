% fazit.tex
\chapter{Zusammenfassung und Ausblick}
\label{cha:fazit}

Es wurde ein Verfahren vorgestellt, das entscheiden kann, ob ein Graph einen \kf-Minor enthält.
Außerdem wurde erklärt, wie sich \kf-Minor-freie Graphen nach dem Theorem von Wagner aufteilen lassen und eine Baumstruktur gezeigt, die diese Aufteilung widerspiegelt.
Für die Implementierung in OGDF wurden im Wesentlichen Block-Cut Trees und SPQR-Bäume verwendet, um $3$-zusammenhängende Graphen zu erzeugen, und anschließend der Boyer-Myrvold Planaritätstest, um solange \dd-Separatoren zu finden, bis ein \kf-Minor gefunden wurde oder der Graph eindeutig \kf-Minor-frei ist.
Bisher werden Zertifikate für $3$-zusammenhängende Graphen, die \kf-Minor-frei sind, erzeugt.
Vor allem die Berechnung von \kf-Modellen im Eingabegraph kann im Hinblick auf den praktischen Nutzen von wesentlicher Bedeutung sein.
Auch kann es für einige praktische Anwendungen sinnvoll sein, den Algorithmus zu erweitern, sodass mehrere \kf-Minoren in Graphen zu berechnen werden können.
Dafür könnte der Algorithmus \zB so angepasst werden, dass in gefundenen \kf-Minoren einzelne Kanten verändert (kontrahiert, entfernt) werden, um bei einem erneuten Durchlauf einen anderen \kf-Minor zu finden.
So könnten viele \kf-Minoren gefunden werden, die sich allerdings kaum unterscheiden und eine hohe Laufzeit verursachen.
Ein weiterer Ansatz könnte daraus bestehen, den Algorithmus nicht zu terminieren, wenn in einer augmentierten Komponente ein \kf-Minor gefunde wurde.
Wird stattdessen in den übrigen Komponenten weitergesucht, ist es möglich, \kf-Minoren zu finden, die sich stark voneinander unterscheiden.
Tests während der experimentellen Analyse haben jedoch angedeutet, dass auf diese Art meist nur einstellige Mengen von \kf-Minoren in den getesteten Graphen gefunden werden konnten.
Da es sich um ein heuristisches Verfahren handelt, wurde es nicht mit in die Arbeit aufgenommen -- einige praktische Anwendungen, wie die Berechnung des maximalen Schnittes in Graphen, die nicht \kf-Minor-frei sind, könnten jedoch davon profitieren.
Es steht aus, diese beiden Ansätze in einer experimentellen Analyse für solche speziellen Anwendungsfälle zu prüfen.

Darüber hinaus gibt es Ansätze in \cite{Li11}, \cite{ReL08} und \cite{ReL}, die in theoretisch linearer Laufzeit entscheiden, ob ein Graph \kf-Minor-frei ist.
Allerdings bleibt die Frage offen, ob eine Implementierung in der Praxis eine bessere Laufzeit aufweisen würde, da teils mit großen Konstanten gearbeitet wird.

Letztlich wären weitere Laufzeittests speziell für Graphen, die nicht planar sind und keinen \kf-Minor enthalten, interessant, da vor allem dann hohe Laufzeiten in der Praxis auftreten können.
Für alle getesteten Graphen konnte der Algorithmus dagegen in wenigen Sekunden entscheiden, ob ein \kf-Minor in einem Graph enthalten ist.
